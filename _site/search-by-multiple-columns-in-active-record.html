<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Searching By Multiple Columns with ActiveRecord and PostgreSQL - Millo's Musings</title><link href="https://fonts.googleapis.com/css?family=Lato:900|Work+Sans" rel="stylesheet"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/syntax.css"><title>Searching By Multiple Columns with ActiveRecord and PostgreSQL - Millo’s Musings</title><meta property="og:title" content="Searching By Multiple Columns with ActiveRecord and PostgreSQL" /><meta name="description" content="My Rails app has a model called Account, and I’ve been tasked with implementing an account search feature. Users type their search query into a form and see a list of accounts which match that query. The problem is that exactly what constitutes a ‘match’ is complicated. Each Account has multiple attributes (email, first_name etc.) which could match the search query, and even some associated models (e.g. an account has_many :phone_numbers) whose attributes should be searchable too." /><meta property="og:description" content="My Rails app has a model called Account, and I’ve been tasked with implementing an account search feature. Users type their search query into a form and see a list of accounts which match that query. The problem is that exactly what constitutes a ‘match’ is complicated. Each Account has multiple attributes (email, first_name etc.) which could match the search query, and even some associated models (e.g. an account has_many :phone_numbers) whose attributes should be searchable too." /><link rel="canonical" href="/search-by-multiple-columns-in-active-record" /><meta property="og:url" content="/search-by-multiple-columns-in-active-record" /><meta property="og:site_name" content="Millo’s Musings" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2017-02-08T00:00:00-02:00" /><script type="application/ld+json"> {"@context": "http://schema.org", "@type": "BlogPosting", "headline": "Searching By Multiple Columns with ActiveRecord and PostgreSQL", "datePublished": "2017-02-08T00:00:00-02:00", "description": "My Rails app has a model called Account, and I’ve been tasked with implementing an account search feature. Users type their search query into a form and see a list of accounts which match that query. The problem is that exactly what constitutes a ‘match’ is complicated. Each Account has multiple attributes (email, first_name etc.) which could match the search query, and even some associated models (e.g. an account has_many :phone_numbers) whose attributes should be searchable too.", "url": "/search-by-multiple-columns-in-active-record"}</script></head><body style="background-color: rgb(255, 255, 255)"><script src="/js/theme.min.js"></script><header> <a href="/"><div class="home"></div></a></header><h1 class="post-headline">Searching By Multiple Columns with ActiveRecord and PostgreSQL</h1><div class="meta"> <span><em>February 08, 2017 by George Millo</em></span></div><p>My Rails app has a model called <code class="highlighter-rouge">Account</code>, and I’ve been tasked with implementing an <em>account search</em> feature. Users type their search query into a form and see a list of accounts which match that query. The problem is that exactly what constitutes a ‘match’ is complicated. Each <code class="highlighter-rouge">Account</code> has multiple attributes (<code class="highlighter-rouge">email</code>, <code class="highlighter-rouge">first_name</code> etc.) which could match the search query, and even some <em>associated</em> models (e.g. an account <code class="highlighter-rouge">has_many :phone_numbers</code>) whose attributes should be searchable too.</p><p>The standard ActiveRecord API isn’t going to cut it here. Maybe I should have just built this app using <a href="http://sequel.jeremyevans.net">Sequel</a>, but for now I’m stuck with ActiveRecord, so it looks like I’m going to have to get my hands dirty and write some raw SQL.</p><p>For the purposes of this article, I’m not going to worry about the front-end interface of my search feature. All I care about for now is creating the function that actually does the searching. Here’s the shell of a class called <code class="highlighter-rouge">Account::Search</code> which I need to finish:</p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Account</span><span class="o">::</span><span class="no">Search</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="c1"># TODO return a list of accounts</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure><p>I’m following the <a href="http://trailblazer.to">Trailblazer</a> convention of encapsulating this logic within a single-purpose class that responds to <code class="highlighter-rouge">call</code>. The <code class="highlighter-rouge">call</code> method takes a string (the search query) as an argument, and it will return a collection of Accounts.</p><p>What should go in the body of the <code class="highlighter-rouge">call</code> method? I have no idea. The requirements are too complicated, so to get started I’m going to implement a simplified version of the feature and see where I can go from there.</p><p>Let’s start by making Accounts searchable by just one attribute - their <code class="highlighter-rouge">email</code>, which is a non-nullable string in the <code class="highlighter-rouge">accounts</code> table. Search should be case-insensitive, and partial matches should return results (so for example if the email address is <code class="highlighter-rouge">george@example.com</code>, you should be able to find it if you just search for <code class="highlighter-rouge">'george'</code>).</p><p>This can be easily accomplished using the the PostgreSQL <code class="highlighter-rouge">ILIKE</code> keyword:</p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
  <span class="no">Account</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'email ILIKE ?'</span><span class="p">,</span> <span class="s2">"%</span><span class="si">#{</span><span class="n">query</span><span class="si">}</span><span class="s2">%"</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure><p>Simple enough. Note that we have to add a <code class="highlighter-rouge">%</code> to the beginning and end of the query string to allow partial matches - you can think of <code class="highlighter-rouge">%</code> in PostgreSQL as being roughly equivalent to <code class="highlighter-rouge">.*</code> in a normal Ruby regex. Also note that the <code class="highlighter-rouge">ILIKE</code> keyword is case-insensitive - the case-sensitive equivalent is called <code class="highlighter-rouge">LIKE</code>.</p><p>That was too easy. An Account also has the attributes <code class="highlighter-rouge">first_name</code> (non-nullable) and <code class="highlighter-rouge">last_name</code> (nullable), and these should be searchable too. How can we make our search function return accounts where the query matches <em>any</em> of these three attributes, not just <code class="highlighter-rouge">email</code>?</p><p>Normally I’d follow TDD and create some RSpec tests for my as-yet-unfinished <code class="highlighter-rouge">Account::Search</code> class, but for the sake of brevity I’ll just provide some example data here that you can create in the rails console (remember that <code class="highlighter-rouge">last_name</code> can be <code class="highlighter-rouge">nil</code> but <code class="highlighter-rouge">email</code> and <code class="highlighter-rouge">first_name</code> can’t):</p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">rob</span>  <span class="o">=</span> <span class="no">Account</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Robert'</span><span class="p">,</span> <span class="ss">last_name: </span><span class="s1">'Brown'</span><span class="p">,</span> <span class="ss">email: </span><span class="s1">'example@example.com'</span><span class="p">)</span>
<span class="n">paul</span> <span class="o">=</span> <span class="no">Account</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Paul'</span><span class="p">,</span> <span class="ss">last_name: </span><span class="s1">'Robertson'</span><span class="p">,</span> <span class="ss">email: </span><span class="s1">'whatever@example.com'</span><span class="p">)</span>
<span class="n">bob</span>  <span class="o">=</span> <span class="no">Account</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Bob'</span><span class="p">,</span> <span class="ss">email: </span><span class="s1">'rob@example.com'</span><span class="p">)</span>
<span class="n">mike</span> <span class="o">=</span> <span class="no">Account</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">first_name: </span><span class="s1">'Mike'</span><span class="p">,</span> <span class="ss">last_name: </span><span class="s1">'Smith'</span><span class="p">,</span> <span class="ss">email: </span><span class="s1">'notamatch@example.com'</span><span class="p">)</span>

<span class="c1"># e.g. Account::Search.call('rob') should return rob, paul, and bob, but not mike.</span></code></pre></figure><p>Here’s my first attempt:</p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Account</span><span class="o">::</span><span class="no">Search</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="no">Account</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s1">'email ILIKE :query OR first_name ILIKE :query OR last_name ILIKE :query'</span><span class="p">,</span> <span class="ss">query: </span><span class="s2">"%</span><span class="si">#{</span><span class="n">query</span><span class="si">}</span><span class="s2">%"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Account</span><span class="o">::</span><span class="no">Search</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'paul'</span><span class="p">)</span>
<span class="c1"># returns Paul Robertson</span>
<span class="no">Account</span><span class="o">::</span><span class="no">Search</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'Rob'</span><span class="p">)</span>
<span class="c1"># returns Robert Brown, Bob, and Paul Robertson</span>
<span class="no">Account</span><span class="o">::</span><span class="no">Search</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'@example.com'</span><span class="p">)</span>
<span class="c1"># returns all four people</span></code></pre></figure><p>This appears to be working… but what if we want to search for someone by their <em>full name</em>? Right now I can find Paul Robertson by searching for “Paul” or for “Robertson”, but if I search for the full string “Paul Robertson” I get no results. That won’t do. Back to the drawing board:</p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
  <span class="no">Account</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"email || ' ' || first_name || ' ' || last_name ILIKE ?"</span><span class="p">,</span> <span class="s2">"%</span><span class="si">#{</span><span class="n">query</span><span class="si">}</span><span class="s2">%"</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure><p>Note that <code class="highlighter-rouge">||</code> is the PostgreSQL operator for <em>concatenation</em>, and doesn’t mean ‘or’ like it does in Ruby. So what I’m doing here is, for each account, concatenating its email, first name, and last name into a single string (with some whitespace in between, so e.g. for Rob we get <code class="highlighter-rouge">'example@example.com Robert Brown'</code>) and comparing the search query (case-insensitiv (case-insensitively)ely) against that full string. Now we can find Paul Robertson if we search for him by his full name.</p><p>Not so fast - something’s still not right. Look what happens when we search for <code class="highlighter-rouge">"rob"</code> with our new method:</p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Account</span><span class="o">::</span><span class="no">Search</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'rob'</span><span class="p">)</span>
<span class="c1"># returns Robert Brown and Paul Robertson</span></code></pre></figure><p>These search results should also include Bob, since his email address is <code class="highlighter-rouge">rob@example.com</code>, but he’s not showing up. What’s going on? I notice that Bob is the only account in my test data that doesn’t have a last name; maybe this is what’s causing the problem.</p><p>To investigate, let’s forget about Ruby for a second and look directly into the database via the PostgreSQL console, which you can fire up using <code class="highlighter-rouge">rails dbconsole</code> or just <code class="highlighter-rouge">psql name_of_database</code>. Let’s see the ‘searchable’ string that’s created for each one of our accounts:</p><figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">email</span> <span class="o">||</span> <span class="s1">' '</span> <span class="o">||</span> <span class="n">first_name</span> <span class="o">||</span> <span class="s1">' '</span> <span class="o">||</span> <span class="n">last_name</span> <span class="k">AS</span> <span class="n">searchable</span> <span class="k">FROM</span> <span class="n">accounts</span><span class="p">;</span>

 <span class="n">first_name</span> <span class="o">|</span>             <span class="n">searchable</span>              
<span class="c1">------------+-------------------------------------</span>
 <span class="n">Robert</span>     <span class="o">|</span> <span class="n">example</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span> <span class="n">Robert</span> <span class="n">Brown</span>
 <span class="n">Paul</span>       <span class="o">|</span> <span class="n">whatever</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span> <span class="n">Paul</span> <span class="n">Robertson</span>
 <span class="n">Bob</span>        <span class="o">|</span> 
 <span class="n">Mike</span>       <span class="o">|</span> <span class="n">notamatch</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span> <span class="n">Mike</span> <span class="n">Smith</span></code></pre></figure><p>Yerwhat? Why is the ‘searchable’ column blank for <code class="highlighter-rouge">Bob</code>?</p><p>It <a href="https://stackoverflow.com/questions/8233746/concatenate-with-null-values-in-sql">turns out</a> that this is a quirk of concatenation in SQL: <em>anything concatenated with <code class="highlighter-rouge">NULL</code> returns <code class="highlighter-rouge">NULL</code></em>. I sup suppose it kinda makes sense when you think about it: what does it even <em>mean</em> to concatenate a string with the null value? Trying to do it in Ruby (<code class="highlighter-rouge">'string' &lt;&lt; nil</code>) will raise an error. So since Bob’s last_name is <code class="highlighter-rouge">NULL</code>, his entire searchable string evaluates to <code class="highlighter-rouge">NULL</code> as well, and will match no queries.</p><p>Thankfully, with a bit more digging I discovered Postgres’s <code class="highlighter-rouge">concat</code> operator, which treats <code class="highlighter-rouge">NULL</code>s like empty strings:</p><figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">first_name</span><span class="p">,</span> <span class="n">concat</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="s1">' '</span><span class="p">,</span> <span class="n">first_name</span><span class="p">,</span> <span class="s1">' '</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span> <span class="k">AS</span> <span class="n">searchable</span> <span class="k">FROM</span> <span class="n">accounts</span><span class="p">;</span>
  <span class="n">first_name</span> <span class="o">|</span>             <span class="n">searchable</span>              
<span class="c1">------------+-------------------------------------</span>
  <span class="n">Robert</span>     <span class="o">|</span> <span class="n">example</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span> <span class="n">Robert</span> <span class="n">Brown</span>
  <span class="n">Paul</span>       <span class="o">|</span> <span class="n">whatever</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span> <span class="n">Paul</span> <span class="n">Robertson</span>
  <span class="n">Bob</span>        <span class="o">|</span> <span class="n">rob</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span> <span class="n">Bob</span> 
  <span class="n">Mike</span>       <span class="o">|</span> <span class="n">notamatch</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span> <span class="n">Mike</span> <span class="n">Smith</span></code></pre></figure><p>Awww yeah! In fact, this can be made a bit prettier using a slightly different function called <code class="highlighter-rouge">concat_ws</code>:</p><p><code class="highlighter-rouge">concat_ws(' ', email, first_name, last_name)</code></p><p>You can think of this as being equivalent to <code class="highlighter-rouge">[email, first_name, last_name].join(' ')</code> in Ruby, noting that if <code class="highlighter-rouge">last_name</code> is <code class="highlighter-rouge">nil</code> then <code class="highlighter-rouge">join</code> will treat it like an empty string.</p><p>At last, I have a serviceable first approximation of my search function. I’ll just make one more little improvement: before I pass the query string to ActiveRecord, I’ll call <code class="highlighter-rouge">squish</code> on it, so that for example searching for <code class="highlighter-rouge">Mike &amp;nbsp; Smith</code> will have the same results as searching for <code class="highlighter-rouge">Mike Smith</code>. Et voila:</p><figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
  <span class="no">Account</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"concat_ws(' ', email, first_name, last_name) ILIKE ?"</span><span class="p">,</span> <span class="s2">"%</span><span class="si">#{</span><span class="n">query</span><span class="p">.</span><span class="nf">squish</span><span class="si">}</span><span class="s2">%"</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure><p>There’s still much more room for improvement. What if we search for someone with their names in the wrong order, like ‘Smith Mike’? That seems like a case we should handle. We also need to test how long this search will take against a large database and if there are any ways we can speed it up - we’ll almost certainly want to add some indexes to our <code class="highlighter-rouge">accounts</code> table to make the search run faster. And of course, in reality my <code class="highlighter-rouge">Account</code> model is much more complicated than this - there are more columns which have their own considerations, and there are some other models associated with <code class="highlighter-rouge">Account</code> which should also be considered in our search results.</p><p>I’ll write about of all that in a future article. Until then, happy searching!</p><hr /><p><em>Thanks to <a href="http://stackoverflow.com/a/22976269/1603071">this StackOverflow question and its answers</a> for getting me on the right track when I was figuring all of this out.</em></p><p><em>The code examples in this article use:</em></p><ul><li><em>Ruby 2.3.0p0</em></li><li><em>Rails + ActiveRecord 5.0.0.1</em></li><li><em>PostgreSQL 9.5.2</em></li><li><em>pg gem 0.19.0</em></li></ul><hr><p><em>Want to make an improvement or correction to this article? <a href='https://github.com/georgemillo/millodotme/tree/master/_posts'>Submit a PR on Github</a></em></p><footer><div class="links"> <a href="/about/">About</a> <a href="/testimonials/">Testimonials</a></div><div class="theme" onclick="theme()" style=" background-image: url(/images/theme.svg)"></div></footer><script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview');</script></body></html>
